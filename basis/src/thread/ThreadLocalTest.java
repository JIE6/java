package thread;

/**
 * ThreadLocal 线程相关类
 * @author JIE
 */
public class ThreadLocalTest {

    public static void main(String[] args) {
        // 启动两个线程，两个线程共享同一个Account
        Account6 at = new Account6("初始名");
        // 虽然两个线程共享同一个账户，即只有一个账户名， 但由于账户名是ThreadLocal 类型的，所以每个线程都完全拥有各自的账户名副本，
        // 因此在i == 6 之后，将看到两个线程访问同一个账户时出现不同的账户名
        new MyTest("甲线程", at).start();
        new MyTest("乙线程", at).start();
    }

    /**
     * 从上面程序可以看出，实际上账户名有三个副本，主线程一个，另外启动的两个线程各一个，它们的值互不干扰， 每个线程完全拥有自己的ThreadLocal 变量，
     * 这就是ThreadLocal 的用途。
     *
     * ThreadLocal 和其他所有的同步机制一样，都是为了解决多线程中对同一变量的访问冲突，
     * 在普通的同步机制中，是通过对象加锁来实现多个线程对同一变量的安全访问的。
     * 该变量是多个线程共享的，所以要使用这种同步机制，需要很细致地分析在什么时候对变量进行读写，什么时候需要锁定某个对象，什么时候释放该对象的锁等。
     * 在这种情况下，系统并没有将这份资源复制多份，只是采用了安全机制来控制对这份资源的访问而己。
     *
     * ThreadLocal 从另一个角度来解决多线程的并发访问，
     * ThreadLocal 将需要并发访问的资源复制多份，每个线程拥有一份资源， 每个线程都拥有自己的资源副本，从而也就没有必要对该变量进行同步了。
     * ThreadLocal 提供了线程安全的共享对象， 在编写多线程代码时，可以把不安全的整个变量封装进ThreadLocal ，或者把该对象与线程相关的状态使用ThreadLocal 保存。
     *
     * ThreadLocal 并不能替代同步机制，两者面向的问题领域不同。
     * 同步机制是为了同步多个线程对相同资源的并发访问， 是多个线程之间进行通信的有效方式;
     * 而ThreadLocal 是为了隔离多个线程的数据共享，从根本上避免多个线程之间对共享资源(变量)的竞争，也就不需要对多个线程进行同步了。
     *
     * 通常建议: 如果多个线程之间需要共享资源，以达到线程之间的通信功能，就使用同步机制; 如果仅仅需要隔离多个线程之间的共享冲突，则可以使用ThreadLocal 。
     */
}

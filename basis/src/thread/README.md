# 多线程

<pre>
    前面所有程序，都只是在做单线程的编程。都只有一条顺序执行流程序从main()方法开始执行，依次向下执行每行代
码，如果程序执行某行代码时遇到了阻塞，则程序将会停滞在该处。如果使用IDE 工具的单步调试功能，就可以非常清楚地看出这一点。
    但实际的情况是，单线程的程序往往功能非常有限，例如开发一个简单的服务器程序，这个服务器程序需要向不同的客户端提供服务时，
不同的客户端之间应该互不干扰，否则会让客户端感觉非常沮丧。多线程昕上去是非常专业的概念，其实非常简单. 单线程的程序只有一个
顺序执行流，多线程的程序则可以包括多个顺序执行流，多个顺序流之间互不干扰。可以这样理解:单线程的程序如同只雇佣一个服务员的餐厅，
他必须做完一件事情后才可以做下一件事情;多线程的程序则如同雇佣多个服务员的餐厅，他们可以同时做多件事情。
    Java 语言提供了非常优秀的多线程支持，程序可以通过非常简单的方式来启动多线程。本章将会详细介绍Java 多线程编程的相关方面，
包括创建、启动线程、控制线程， 以及多线程的同步操作，并会介绍如何利用Java 内建支持的线程池来提高多线程性能。

    几乎所有的操作系统都支持同时运行多个任务，一个任务通常就是一个程序，每个运行中的程序就是一个进程。当一个程序运行时，
内部可能包含了多个顺序执行流，每个顺序执行流就是一个线程。
</pre>

## 当前包下需重点掌握的知识点
| 位置 | 重要等级(1 ~ 5)<small>数字越大等级越高</small> | 简述 |
|:----:|:----:|:----:|
| FirstThread | 5 | 继承Thread 类创建线程类 |
| SecondThread | 5 | 实现Runnable 接口创建线程类 |
| ThirdThread | 5 | 使用Callable 和Future 创建线程 |
| 当前位置往下第77行 | 5 | 创建线程的三种方式对比 |
| 当前位置往下第94行 | 5 | 线程的生命周期 |
| JoinThread | 5 | 控制线程 - join 线程 |
| DaemonThread | 5 | 控制线程 - 后台线程 |
| SleepTest | 5 | 控制线程 - 线程睡眠: sleep |
| PriorityTest | 5 | 控制线程 - 改变线程优先级|
| Account,DrawThread | 5 | 线程同步 - 银行取钱的问题 |
| DrawThread2 | 5 | 同步代码块 - 解决银行取钱的问题 |
| Account2,DrawThread3 | 5 | 同步方法 - 银行取钱 |
| 当前位置往下第196行 | 5 | 释放同步监视器的锁 |
| Account3 | 5 | 同步锁(Lock) |
| DeadLock | 5 | 死锁 |
| Account4,DrawThread4,DepositThread,DrawTest | 5 | 线程通信 - 传统的线程通信 |
| Account5,DrawThread5,DepositThread2,DrawTest2 | 5 | 线程通信 - 使用Condition 控制线程通信 |
| BlockingQueueTest,Producer,Consumer,BlockingQueueTest2 | 5 | 线程通信 - 使用阻塞队列(BlockingQueue) 控制线程通信 |
| MyThread | 5 | 线程组 |
| MyExHandler | 5 | 定义自己的异常处理器 |
| 当前位置往下第218行 | 5 | 线程池 与 Java 8 改进的线程池 |
| ThreadPoolTest | 5 | 线程池 |
| PrintTask,ForkJoinPoolTest | 5 | Java8 增强的ForkJoinPool - 无返回值 |
| CalTask,Sum | 5 | Java8 增强的ForkJoinPool - 有返回值 |
| Account6,MyTest,ThreadLocalTest | 5 | ThreadLocal 线程相关类 |
| 当前位置往下第288行 | 5 | 包装线程不安全的集合 |
| 当前位置往下第308行 | 5 | 线程安全的集合类 |
| PubSubTest,MySubscriber | 5 | Java 9 新增的发布·订阅框架 |


### 线程和进程
<pre>
    几乎所有的操作系统都支持进程的概念，所有运行中的任务通常对应一个进程( Process) 。当一个程序进入内存运行时，即变成一个进程。
进程是处于运行过程中的程序， 并且具有一定的独立功能，进程是系统进行资源分配和调度的一个独立单位。
    一般而言，进程包含如下三个特征。
    独立性: 进程是系统中独立存在的实体，它可以拥有自己独立的资源，每一个进程都拥有自己私有的地址空间。在没有经过进程本身允许的情况下，
一个用户进程不可以直接访问其他进程的地址空间。
    动态性:进程与程序的区别在于，程序只是一个静态的指令集合，而进程是一个正在系统中活动的指令集合。在进程中加入了时间的概念。进程具有自己的生命周期和各种不同的状态，
这些概念在程序中都是不具备的。
    并发性: 多个进程可以在单个处理器上井发执行， 多个进程之间不会互相影响。
    
    并发性( concurrency )和并行性( parallel) 是两个概念， 并行指在同一时刻，有多条指令在多个处理器上同时执行;并发指在同一时刻只能有一条指令执行， 但多个进程指令
指令在多个处理器上同时执行;并发指在同一时刻只能有一条指令执行， 但多个进程指令被快速轮换执行，使得在宏观上具有多个进程同时执行的效果。

    大部分操作系统都支持多进程并发运行，现代的操作系统几乎都支持同时运行多个任务。例如，程序员一边开着开发工具在写程序， 一边开着参考手册备查，同时还使用电脑播放音乐...
除此之外，每台电脑运行时还有大量底层的支撑性程序在运行...这些进程看上去像是在同时工作。
    但事实的真相是，对于一个CPU 而言，它在某个时间点只能执行一个程序， 也就是说，只能运行一个进程， CPU 不断地在这些进程之间轮换执行。那为什么用户感觉不到任何中断现象呢?
这是因为CPU 的执行速度相对人的感觉来说实在是太快了(如果启动的程序足够多， 用户依然可以感觉到程序的运行速度下降) ，所以虽然CPU 在多个进程之间轮换执行，
但用户感觉到好像有多个进程在同时执行。
    现代的操作系统都支持多进程的并发，但在具体的实现细节上可能因为硬件和操作系统的不同而采用不同的策略。比较常用的方式有: 共用式的多任务操作策略，例如Windows3.1 和Mac OS 9;
目前操作系统大多采用效率更高的抢占式多任务操作策略，例如Windows NT 、Windows 2000 以及UNIX / Linux等操作系统。

    多线程则扩展了多进程的概念，使得同一个进程可以同时并发处理多个任务。线程 (Thread ) 也被称作轻量级进程( Lightweight Process) ，线程是进程的执行单元。
就像进程在操作系统中的地位一样，线程在程序中是独立的、并发的执行流。当进程被初始化后，主线程就被创建了。对于绝大多数的应用程序来说，通常仅要求有一个主线程，
但也可以在该进程内创建多条顺序执行流，这些顺序执行流就是线程，每个线程也是互相独立的。
    线程是进程的组成部分， 一个进程可以拥有多个线程，一个线程必须有一个父进程。线程可以拥有自己的堆枝、自己的程序计数器和自己的局部变量，但不拥有系统资源，
它与父进程的其他线程共享该进程所拥有的全部资源。因为多个线程共享父进程里的全部资源，因此编程更加方便;但必须更加小心，因为需要确保线程不会妨碍同一进程里的其他线程。
    线程可以完成一定的任务，可以与其他线程共享父进程中的共享变量及部分环境，相互之间协同来完成进程所要完成的任务。
    线程是独立运行的，它并不知道进程中是否还有其他线程存在。线程的执行是抢占式的，也就是说，当前运行的线程在任何时候都可能被挂起，以便另外一个线程可以运行。
    一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行。
    从逻辑角度来看，多线程存在于一个应用程序中，让一个应用程序中可以有多个执行部分同时执行，但操作系统无须将多个线程看作多个独立的应用，对多线程实现调度和管理以及资源分配。线
程的调度和管理由进程本身负责完成。
    简而言之， 一个程序运行后至少有一个进程， 一个进程里可以包含多个线程，但至少要包含一个线程。
    归纳起来可以这样说:操作可以同时执行多个任务，每个任务叫进程；进程可以同时执行多个任务；每个任务就是线程
</pre>

### 多线程的优势
<pre>
    线程在程序中是独立的、并发的执行流，与分隔的进程相比，进程中线程之间的隔离程度要小。它们共享内存、文件句柄和其他每个进程应有的状态。
    因为线程的划分尺度小于进程，使得多线程程序的并发性高。进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。
    线程比进程具有更高的性能，这是由于同一个进程中的线程都有共性.多个线程共享同一个进程虚拟空间。线程共享的环境包括:进程代码段、进程的公有数据等。
利用这些共享的数据，线程很容易实现相互之间的通信。
    当操作系统创建一个进程时，必须为该进程分配独立的内存空间，并分配大量的相关资源; 但创建一个线程则简单得多，因此使用多线程来实现并发比使用多进程实现并发的性能要高得多。
    总结起来，使用多线程编程具有如下几个优点。
    1.进程之间不能共享内存，但线程之间共享内存非常容易。
    2.系统创建进程时需要为该进程重新分配系统资源，但创建线程则代价小得多，因此使用多线程来实现多任务并发比多进程的效率高。
    3.Java 语言内置了多线程功能支持，而不是单纯地作为底层操作系统的调度方式，从而简化了Java的多线程编程。
    在实际应用中，多线程是非常有用的， 一个浏览器必须能同时下载多个图片:一个Web 服务器必须能同时响应多个用户请求; Java 虚拟机本身就在后台提供了一个超级线程来进行垃圾回收...
总之，多线程在实际编程中的应用是非常广泛的。
</pre>

### 创建线程的三种方式对比
<pre>
    通过继承Thread 类或实现Runnable 、Callable 接口都可以实现多线程，不过实现Runnable 接口与实现Callable 接口的方式基本相同，
只是Callable 接口里定义的方法有返回值，可以声明抛出异常而己。因此可以将实现Runnable 接口和实现Callable 接口归为一种方式。
这种方式与继承Thread 方式之间的主要差别如下。
    采用实现Runnable 、Callable 接口的方式创建多线程的优缺点:
    线程类只是实现了Runnable 接口或Callable 接口， 还可以继承其他类。
    在这种方式下，多个线程可以共享同一个target 对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，
形成清晰的模型，较好地体现了面向对象的思想。
    劣势是，编程稍稍复杂，如果需要访问当前线程，则必须使用Thread.currentThread()方法。
    采用继承Thread 类的方式创建多线程的优缺点:
    劣势是，因为线程类己经继承了Thread 类，所以不能再继承其他父类。
    优势是，编写简单，如果需要访问当前线程，则无须使用Thread.currentThread()方法，直接使用this 即可获得当前线程。
    鉴于上面分析，因此一般推荐采用实现Runnable 接口、Callable 接口的方式来创建多线程。
</pre>

### 线程的生命周期
<pre>
    当线程被创建井启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态，在线程的生命周期中，
它要经过新建( New) 、就绪CRunnable) 、运行( Running ) 、阻塞( Blocked ) 和死亡( Dead )
5 种状态。尤其是当线程启动以后，它不可能一直"霸占"着CPU 独自运行，所以CPU 需要在多条线程之间切换，
于是线程状态也会多次在运行、就绪之间切换。

    新建和就绪状态
    当程序使用new 关键宇创建了一个线程之后，该线程就处于新建状态，此时它和其他的Java 对象一样，仅仅由Java 虚拟机为其分配内存，
并初始化其成员变量的值。此时的线程对象没有表现出任何线程的动态特征，程序也不会执行线程的线程执行体。
当线程对象调用了start()方法之后，该线程处于就绪状态， Java 虚拟机会为其创建方法调用栈和程序计数器，处于这个状态中的线程并没有开始运行，
只是表示该线程可以运行了。至于该线程何时开始运行， 取决于jvm 里线程调度器的调度。
    调用线程对象的start方法之后，该线程立即进入就绪状态, 就绪状态相当于"等待执行"，但该线程并未真正进入运行状态。
如果希望调用子线程的start()方法后子线程立即开始执行，程序可以使用Thread.sleep(1)来让当前运行的线程(主线程)睡眠 1 毫秒,
1 毫秒就够了，因为在这 1 毫秒内CPU不会空闲，它会去执行另一个处于就绪状态的线程，这样就可以让子线程立即开始执行。

    运行和阻塞状态
    如果处于就绪状态的线程获得了CPU ，开始执行run()方法的线程执行体，则该线程处于运行状态，如果计算机只有一个CPU ， 那么在任何时刻只有一个线程处于运行状态。
当然，在一个多处理器的机器上，将会有多个线程并行(注意是并行: parallel ) 执行;当线程数大于处理器数时，依然会存在多个线程在同一个CPU 上轮换的现象。
    当一个线程开始运行后，它不可能一直处于运行状态(除非它的线程执行体足够短，瞬间就执行结束了) ，线程在运行过程中需要被中断，目的是使其他线程获得执行的机会，
线程调度的细节取决于底层平台所采用的策略。对于采用抢占式策略的系统而言，系统会给每个可执行的线程一个小时间段来处理任务:当该时间段用完后，系统就会剥夺该线程所占用的资源，
让其他线程获得执行的机会。在选择下一个线程时，系统会考虑线程的优先级。
    所有现代的桌面和服务器操作系统都采用抢占式调度策略，但一些小型设备如手机则可能采用协作式调度策略，在这样的系统中，只有当一个线程调用了它的sleep()或yield()方法后
才会放弃所占用的资源, 也就是必须由该线程主动放弃所占用的资源。
    当发生如下情况时，线程将会进入阻塞状态:
    线程调用sleep()方法主动放弃所占用的处理器资源。
    线程调用了一个阻塞式 IO 方法，在该方法返回之前，该线程被阻塞。
    线程试图获得一个同步监视器，但该同步监视器正被其他线程所持有。关于同步监视器的知识、后面将有更深入的介绍。
    线程在等待某个通知( notify )。
    程序调用了线程的suspend()方法将该线程挂起。但这个方法容易导致死锁，所以应该尽量避免使用该方法。
    当前正在执行的线程被阻塞之后，其他线程就可以获得执行的机会。被阻塞的线程会在合适的时候重新进入就绪状态，注意是就绪状态而不是运行状态。也就是说，被阻塞线程的阻塞解除后，
    必须重新等待线程调度器再次调度它。
    针对上面几种情况，当发生如下特定的情况时可以解除上面的阻塞，让该线程重新进入就绪状态。
    调用sleep()方法的线程经过了指定时间。
    线程调用的阻塞式 IO 方法已经返回。
    线程成功地获得了试图取得的同步监视器。
    线程正在等待某个通知时，其他线程发出了一个通知。
    处于挂起状态的线程被调用了resume()恢复方法。
    下图显示了线程状态转换图。
------------------------------------------------------------------------------------------------------------------------------
    新建
     ↓
     ↓ - start()
     ↓
    就绪
     ↓
     ↓ - 或得到处理器资源
     ↓
    运行 ->->-> sleep()/IO阻塞/等待同步锁/等待通知/suspend() ->->-> 阻塞                - yield()失去处理器资源
                                                                 ↓
                                                                 ↓
     <- sleep()时间到/IO方法返回/收到同步锁/收到通知/resume() <-<-<- 就绪        - 得到处理器资源
     ↓
     ↓
    运行 ->->-> sleep()/IO阻塞/等待同步锁/等待通知/suspend() ->->-> 阻塞                - yield()失去处理器资源
                                                                  ↓
                                                                  ↓
     <- sleep()时间到/IO方法返回/收到同步锁/收到通知/resume() <-<-<- 就绪        - 得到处理器资源
     ↓
     ↓
    运行 ->->-> sleep()/IO阻塞/等待同步锁/等待通知/suspend() ->->-> 阻塞                - yield()失去处理器资源
                                                                  ↓
                                                                  ↓
     <- sleep()时间到/IO方法返回/收到同步锁/收到通知/resume() <-<-<- 就绪        - 得到处理器资源
     ↓
     ↓
    运行
     ↓
     ↓ - stop()/Error或Exception/run()或call()执行完成
     ↓
    死亡
------------------------------------------------------------------------------------------------------------------------------
    从上图中可以看出， 线程从阻塞状态只能进入就绪状态，无法直接进入运行状态。而就绪和运行状态之间的转换通常不受程序控制，而是由系统线程调度所决定，
当处于就绪状态的线程获得处理器资源时， 该线程进入运行状态;当处于运行状态的线程失去处理器资源时，该线程进入就绪状态。但有一个方法例外，
调用yield()方法可以让运行状态的线程转入就绪状态。关于yield()方法后面有更详细的介绍。

    线程死亡
    线程会以如下三种方式结束，结束后就处于死亡状态。
    run()或call()方法执行完成，线程正常结束。
    线程抛出一个未捕获的Exception 或Error
    直接调用该线程的stop()方法来结束该线程, 该方法容易导致死锁，通常不推荐使用。
    
    注意：
    启动线程使用start()方法，而不是run()方法!永远不要调用线程对象的run()方法!
    调用start()方法来启动线程，系统会把该run()方法当成线程执行体来处理;但如果直接调用线程对象的run()方法，则 run()方法立即就会被执行，
而且在run()方法返回之前其他线程无法并发执行. 也就是说，如果直接调用线程对象的run()方法，系统把线程对象当成一个普通对象，而run()方法也是一个普通方法， 而不是线程执行体。

    只能对处于新建状态的线程调用start()方法，否则将引发IllegalThreadStateException异常。
    当主线程结束时，其他线程不受任何影响，并不会随之结束。一旦子线程启动起来后，它就拥有和主线程相同的地位，它不会受主线程的影响。
    为了测试某个线程是否己经死亡，可以调用线程对象的isAlive()方法， 当线程处于就绪、运行、阻塞三种状态时，该方法将返回true;当线程处于新建、死亡两种状态时，该方法将返回false。
    不要试图对一个已经死亡的线程调用start()方法使它重新启动， 死亡就是死亡，该线程将不可再次作为线程执行。
</pre>

### 释放同步监视器的锁
<pre>
    任何线程进入同步代码块、同步方法之前，必须先获得对同步监视器的锁定， 那么何时会释放对同步监视器的锁定呢?程序无法显式释放对同步监视器的锁定，
    
    线程会在如下几种情况下释放对同步监视器的锁定:
    1.当前线程的同步方法、同步代码块执行结束，当前线程即释放同步监视器。
    2.当前线程在同步代码块、同步方法中遇到break 、return 终止了该代码块、该方法的继续执行，当前线程将会释放同步监视器。(finally{...})
    3.当前线程在同步代码块、同步方法中出现了未处理的Error 或Exception ，导致了该代码块、该方法异常结束时， 当前线程将会释放同步监视器。
    4.当前线程执行同步代码块或同步方法时， 程序执行了同步监视器对象的wait()方法，则当前线程暂停，并释放同步监视器。
    
    在如下所示的情况下， 线程不会释放同步监视器:
    1.线程执行同步代码块或同步方法时，程序调用Thread.sleep() 、Thread.yield()方法来暂停当前线程的执行，当前线程不会释放同步监视器。
    2.线程执行同步代码块时， 其他线程调用了该线程的suspend()方法将该线程挂起， 该线程不会释放同步监视器。当然， 程序应该尽量避免使用suspend()和resume()方法来控制线程。
</pre>

### 线程池
<pre>
    系统启动一个新线程的成本是比较高的，因为它涉及与操作系统交互。在这种情形下，使用线程池可以很好地提高性能，尤其是当程序中需要创建大量生存期很短暂的线程时，
更应该考虑使用线程池。
    与数据库连接池类似的是，线程池在系统启动时即创建大量空闲的线程，程序将一个Runnable 对象或Callable 对象传给线程池，线程池就会启动一个空闲的线程来执行它们的
run()或callO()方法， 当run()或call()方法执行结束后，该线程并不会死亡，而是再次返回线程池中成为空闲状态， 等待执行下一个Runnable 对象的run()或call()方法。
    除此之外，使用线程池可以有效地控制系统中并发线程的数量， 当系统中包含大量并发线程时， 会导致系统性能剧烈下降，甚至导致 JVM 崩溃，
而线程池的最大线程数参数可以控制系统中并发线程数不超过此数。


    Java 8 改进的线程池
    
    在Java 5 以前，开发者必须手动实现自己的线程池:从Java 5 开始， Java 内建支持线程池。Java 5新增了一个Executors 工厂类来产生线程池， 
该工厂类包含如下几个静态工厂方法来创建线程池。
    
    newCachedThreadPool(): 创建一个具有缓存功能的线程池， 系统根据需要创建线程，这些线程将会被缓存在线程池中。
    
    newFixedThreadPool(int nThreads): 创建一个可重用的、具有固定线程数的线程池。
    
    newSingleThreadExecutorO: 创建一个只有单线程的线程池，它相当于调用newFixedThreadPool()方法时传入参数为l 。
    
    newScheduledThreadPool(int corePooISize): 创建具有指定线程数的线程池， 它可以在指定延迟后执行线程任务。
corePoolSize 指池中所保存的线程数，即使线程是空闲的也被保存在线程池内。

    newSingleThreadScheduledExecutor(): 创建只有一个线程的线程池，它可以在指定延迟后执行线程任务。
    
    ExecutorService newWorkStealingPool(int parallelism): 创建持有足够的线程的线程池来支持给定的并行级别，该方法还会使用多个队列来减少竞争。
    
    ExecutorService newWorkStealingPool(): 该方法是前一个方法的简化版本。如果当前机器有4 个CPU ，则目标并行级别被设置为4 ，也就是相当于为前一个方法传入4 作为参数。
    
    上面 7 个方法中的前三个方法返回一个ExecutorService 对象，该对象代表一个线程池，它可以执行Runnable 对象或Callable 对象所代表的线程:
    而中间两个方法返回一个ScheduledExecutorService 线程池，它是ExecutorService 的子类，它可以在指定延迟后执行线程任务:
    最后两个方法则是Java 8 新增的，这两个方法可充分利用多CPU 并行的能力。这两个方法生成的work stealing 池，都相当于后台线程池，
如果所有的前台线程都死亡了， work stealing 池中的线程会自动死亡。

    由于目前计算机硬件的发展日新月异，即使普通用户使用的电脑通常也都是多核CPU ，因此Java 8在线程支持上也增加了利用多CPU 并行的能力， 这样可以更好地发挥底层硬件的性能。
    
    ExecutorService 代表尽快执行线程的线程池(只要线程池中有空闲线程，就立即执行线程任务) ,程序只要将一个Runnable 对象或Callable 对象( 代表线程任务)提交给该线程池， 
该线程池就会尽快执行该任务。ExecutorService 里提供了如下三个方法。
    Future<?> submit(Runnable task): 将一个Runnable 对象提交给指定的线程池， 线程池将在有空闲线程时执行Runnable 对象代表的任务。其中Future 对象代表Runnable 任务的返回值
但run()方法没有返回值， 所以Future 对象将在run()方法执行结束后返回null 。但可以调用Future的isDone() 、isCancelled()方法来获得Runnable 对象的执行状态。
    <T> Future<T> submit(Runnable task, T result) : 将一个Runnable 对象提交给指定的线程池， 线程池将在有空闲线程时执行Runnable 对象代表的任务。
其中result 显式指定线程执行结束后的返回值， 所以Future 对象将在run()方法执行结束后返回result。
    <T> Future<T> submit(Callable<T> task): 将一个Callable 对象提交给指定的线程池， 线程池将在有雪闲线程时执行Callable 对象代表的任务。
其中Future 代表Callable 对象里call()方法的返回值。

    ScheduledExecutorService 代表可在指定延迟后或周期性地执行线程任务的线程池， 它提供了如下4个方法。
    ScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUnit unit) : 指定callable 任务将在delay 延迟后执行。
    ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) : 指定command 任务将在delay 延迟后执行。
    ScheduledFuture<?> scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit): 指定command 任务将在delay 延迟后执行，
而且以设定频率重复执行。也就是说， 在initialDelay 后开始执行，依次在initialDelay+period 、initialDelay+2 *period... 处重复执行，依此类推。
    ScheduledFuture<?> scheduleWithFixedDelay(Runnable command, long initialDelay, long delay,TimeUnit unit): 创建并执行一个在给定初始延迟后首次启用的定期操作，
随后在每一次执行终止和下一次执行开始之间都存在给定的延迟。如果任务在任一次执行时遇到异常，就会取消后续执行: 否则， 只能通过程序来显式取消或终止该任务。

    用完一个线程池后， 应该调用该线程池的shutdown()方法， 该方法将启动线程池的关闭序列，调用shutdown()方法后的线程池不再接收新任务，但会将以前所有己提交任务执行完成。
当线程池中的所有任务都执行完成后，池中的所有线程都会死亡: 另外也可以调用线程池的shutdownNow()方法来关闭线程池，该方法试图停止所有正在执行的活动任务， 暂停处理正在等待的任务， 
并返回等待执行的任务列表。

    使用线程池来执行线程任务的步骤如下。
    1.调用Executors 类的静态工厂方法创建一个ExecutorService 对象，该对象代表一个线程池。
    2.创建Runnable 实现类或Callable 实现类的实例，作为线程执行任务。
    3.调用ExecutorService 对象的submit()方法来提交Runnable 实例或Callable 实例。
    4.当不想提交任何任务时，调用ExecutorService 对象的shutdownO方法来关闭线程池。
</pre>

### 包装线程不安全的集合
<pre>
    前面介绍Java 集合时所讲的ArrayList 、LinkedList 、HashSet 、TreeSet 、HashMap 、TreeMap 等都是线程不安全的，
也就是说，当多个并发线程向这些集合中存、取元素时，就可能会破坏这些集合的数据完整性。
    如果程序中有多个线程可能访问以上这些集合，就可以使用Collections 提供的类方法把这些集合包装成线程安全的集合。
    Collections 提供了如下几个静态方法。
    <T> Collection<T> synchronizedCollection(Collection<T> c): 返回指定collection 对应的线程安全的collection。
    static <T> List<T> synchronizedList(List<T> list) : 返回指定List 对象对应的线程安全的List 对象。
    static <K,V> Map<K,V> synchronizedMap(Map<K,V> m) : 返回指定Map 对象对应的线程安全的Map 对象。
    static <T> Set<T> synchronizedSet(Set<T> s) : 返回指定Set 对象对应的线程安全的Set 对象。
    static <K,V> SortedMap<K,V> synchronizedSortedMap(SortedMap<K,V> m): 返回指定SortedMap对象对应的线程安全的SortedMap 对象。
    static <T> SortedSet<T> synchronizedSortedSet(SortedSet<T> s): 返回指定SortedSet 对象对应的线程安全的SortedSet 对象。
    
    例如需要在多线程中使用线程安全的HashMap 对象，则可以采用如下代码:
    // 使用Collections 的synchronizedMap 方法将一个普通的HashMap 包装成线程安全的类
    HashMap m = Collections.synchronizedMap (new HashMap());
    如果需要把某个集合包装成线程安全的集合， 则应该在创建之后立即包装， 如上程序所示， 当HashMap 对象创建后立即被包装成线程安全的HashMap 对象。    
</pre>

### 线程安全的集合类
<pre>
    实际上从Java 5 开始，在Java.util.concurrent 包下提供了大量支持高效并发访问的集合接口和实现类.
    这些线程安全的集合类可分为如下两类。
    以Concurrent 开头的集合类，如ConcurrentHashMap 、ConcurrentSkipListMap 、ConcurrentSkipListSet、ConcurrentLinkedQueue 和 ConcurrentLinkedDeque 。
    以CopyOnWrite 开头的集合类，如CopyOnWriteArrayList 、C opyOn WriteArraySet 。
    
    其中以Concurrent 开头的集合类代表了支持并发访问的集合， 它们可以支持多个线程并发写入访问，这些写入线程的所有操作都是线程安全的，但读取操作不必锁定。
以Concurrent 开头的集合类采用了更复杂的算法来保证永远不会锁住整个集合，因此在并发写入时有较好的性能。
    当多个线程共享访问一个公共集合时， ConcurrentLinkedQueue 是一个恰当的选择。ConcurrentLinkedQueue 不允许使用null 元素。ConcurrentLinkedQueue 实现了多线程的高效访问，
多个线程访问ConcurrentLinkedQueue 集合时无须等待。
    在默认情况下， ConcurrentHashMap 支持16 个线程并发写入，当有超过16 个线程并发向该Map中写入数据时，可能有一些线程需要等待。实际上， 
程序通过设置concurrencyLevel 构造参数(默认值为16 ) 来支持更多的并发写入线程。
    与前面介绍的HashM ap 和普通集合不同的是， 因为ConcurrentLinkedQueue 和ConcurrentHashMap支持多线程并发访问，所以当使用法代器来遍历集合元素时，
该迭代器可能不能反映出创建迭代器之后所做的修改，但程序不会抛出任何异常。
    Java 8 扩展了ConcurrentHashMap 的功能， Java 8 为该类新增了30 多个新方法，这些方法可借助于Stream 和Lambda 表达式支持执行聚集操作。
    ConcurrentHashMap 新增的方法大致可分为如下三类。
    forEach 系列( forEach， forEachKey, forEachValue, forEachEntry )
    search 系列( search ， searchKeys, searchValues, searchEntries)
    reduce 系列( reduce ， reduceToDouble, reduceToLong, reduceKeys, reduce Values )
    除此之外， ConcurrentHashMap 还新增了mappingCount() 、newKeySet() 等方法， 增强后的ConcurrentHashMap 更适合作为缓存实现类使用。
    使用java.util 包下的Collection 作为集合对象时，如果该集合对象创建迭代器后集合元素发生改变，则会引发ConcurrentModificationException 异常。
    
    由于CopyOnWriteArraySet 的底层封装了CopyOnWriteArrayList ， 因此它的实现机制完全类似于CopyOn WriteArrayList 集合。
    对于CopyOnWriteArrayList 集合， 正如它的名字所暗示的，它采用复制底层数组的方式来实现写操作。
    当线程对CopyOnWriteArrayList 集合执行读取操作时，线程将会直接读取集合本身，无须加锁与阻塞。当线程对CopyOnWriteArrayList 集合执行写入操作时
(包括调用add() 、remove() 、set()等方法) ,该集合会在底层复制一份新的数组，接下来对新的数组执行写入操作。
由于对CopyOnWriteArrayList集合的写入操作都是对数组的副本执行操作，因此它是线程安全的。
    需要指出的是， 由于CopyOnWriteArrayList 执行写入操作时需要频繁地复制数组，性能比较差， 但由于读操作与写操作不是操作同一个数组，而且读操作也不需要加锁，
因此读操作就很快、很安全。由此可见， CopyOnWriteArrayList 适合用在读取操作远远大于写入操作的场景中， 例如缓存等。
</pre>
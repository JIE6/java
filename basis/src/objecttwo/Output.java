package objecttwo;

/**
 * interface关键字
 * 和类定义不同，定义接口不再使用class 关键字，而是使用interface 关键字。接口定义的基本语法如下:
 * [修饰符] interface 接口名 extends 父接口1 ，父接口2. . .{
 *     零个到多个常量定义.. .
 *     零个到多个抽象方法定义.. .
 *     零个到多个内部类、接口、枚举定义.. .
 *     零个到多个私有方法、默认方法或类方法定义.. .
 * }
 *
 * 对上面语法的详细说明如下。
 * 修饰符可以是public 或者省略，如果省略了public 访问控制符，则默认采用包权限访问控制符，即只有在相同包结构下才可以访问该接口。
 * 一个接口可以有多个直接父接口，但接口只能继承接口，不能继承类。
 * 在上面语法定义中，只有在Java 8 以上的版本中才允许在接口中定义默认方法、类方法
 *
 * 由于接口定义的是一种规范，因此接口里不能包含构造器和初始化块定义
 * 接口里可以包含成员变量(只能是静态常量)、方法(只能是抽象实例方法、类方法、默认方法或私有方法)、内部类(包括内部接口、枚举)定义。
 *
 * 接口里定义的是多个类共同的公共行为规范，因此接口里的常量、方法、内部类和内部枚举都是public 访问权限。定义接口成员时，可以省略访问控制修饰符，
 * 如果指定访问控制修饰符，则只能使用public 访问控制修饰符。
 *
 * 对于接口里定义的静态常量而言，它们是接口相关的，因此系统会自动为这些成员变量增加static和final 两个修饰符。
 * 也就是说，在接口中定义成员变量时，不管是否使用public static final 修饰符，接口里的成员变量总是使用这三个修饰符来修饰。
 * 而且接口里没有构造器和初始化块，因此接口里定义的成员变量只能在定义时指定默认值。
 *
 * 接口里定义成员变量采用如下两行代码的结果完全一样
 * int MAX_SIZE = 50;
 * public static final int MAX_SIZE = 50;
 *
 * 接口里定义的方法只能是抽象方法、类方法、默认方法或私有方法，因此如果不是定义默认方法、类方法或私有方法，系统将自动为普通方法增加abstract 修饰符:
 * 定义接口里的普通方法时不管是否使用public abstract 修饰符，接口里的普通方法总是使用public abstract 来修饰。
 * 接口里的普通方法不能有方法实现(方法体);但类方法、默认方法、私有方法都必须有方法实现(方法体〉。
 *
 * 接口里定义的内部类、内部接口、内部枚举默认都采用public static 两个修饰符，不管定义时是否指定这两个修饰符，系统都会自动使用public static 对它们进行修饰。
 * @author JIE
 */
public interface Output {

    /**
     * 接口里定义的成员变量只能是常量
     */
    int MAX_CACHE_LINE = 2;

    /**
     * 接口里定义的普通方法只能是public 的抽象方法
     */
    void out();

    /**
     * 接口里定义的普通方法只能是public 的抽象方法
     * @param data
     */
    void getData(String data);

    /**
     * 在接口中定义默认方法，需要使用default 修饰
     *
     * Java 8 允许在接口中定义默认方法，默认方法必须使用default 修饰，该方法不能使用static 修饰，
     * 无论程序是否指定，默认方法总是使用public 修饰, 如果开发者没有指定public ， 系统会自动为默认方法添加public 修饰符。
     * 由于默认方法并没有static 修饰，因此不能直接使用接口来调用默认方法，需要使用接口的实现类的实例来调用这些默认方法。
     *
     * 接口的默认方法其实就是实例方法，但由于早期Java 的设计是:接口中的实例方法不能有方法体; Java 8 也不能直接"推倒"以前的规则，
     * 因此只好重定义一个所谓的"默认方法"，默认方法就是有方法体的实例方法
     * @param message
     */
    default void print(String message) {
        System.out.println(message);
    }

    /**
     * 在接口中定义类方法，需要使用static 修饰
     *
     * Java 8 允许在接口中定义类方法， 类方法必须使用static 修饰， 该方法不能使用default 修饰，无论程序是否指定，类方法总是使用public 修饰
     * 如果开发者没有指定public ，系统会自动为类方法添加public 修饰符。类方法可以直接使用接口来调用
     */
    static void staticTest() {
        System.out.println("staticTest");
    }

    /**
     * 定义私有方法
     *
     * Java 9 增加了带方法体的私有方法，这也是Java 8 埋下的伏笔: Java 8 允许在接口中定义带方法体的默认方法和类方法
     * 这样势必会引发一个问题， 当两个默认方法(或类方法) 中包含一段相同的实现逻辑时，程序必然考虑将这段实现逻辑抽取成工具方法，
     * 而工具方法是应该被隐藏的，这就是Java 9增加私有方法的必然性。
     */
    private void foo() {
        System.out.println("foo");
    }

    /**
     * 定义静态私有方法
     */
    private static void bar() {
        System.out.println("bar");
    }
}

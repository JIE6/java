package objecttwo.objectgc;

/**
 * 对象在内存中的状态
 * 当一个对象在堆内存中运行时，根据它被引用变量所引用的状态，可以把它所处的状态分成如下三种。
 * 1.可达状态: 当一个对象被创建后，若有一个以上的引用变量引用它，则这个对象在程序中处于可达状态，
 * 程序可通过引用变量来调用该对象的实例变量和方法。
 * 2.可恢复状态:如果程序中某个对象不再有任何引用变量引用它，它就进入了可恢复状态。
 * 在这种状态下，系统的垃圾回收机制准备回收该对象所占用的内存，在回收该对象之前，系统会调用所有可恢复状态对象的finalize()方法进行资源清理。
 * 如果系统在调用finalize()方法时重新让一个引用变量引用该对象，则这个对象会再次变为可达状态;否则该对象将进入不可达状态。
 * 3.不可达状态:当对象与所有引用变量的关联都被切断，且系统已经调用所有对象的finalize()方法后依然没有使该对象变成可达状态，
 * 那么这个对象将永久性地失去引用，最后变成不可达状态。只有当一个对象处于不可达状态时，系统才会真正回收该对象所占有的资源。
 *
 * 下图 显示了对象的三种状态的转换示意图。
 * 对象  ->      创建之后   ->   可达状态
 *                         ↓      ↑
 *                 失去引用 ↓      ↑ 重新获得引用
 *                         ↓      ↑
 *                        可恢复状态
 *                            ↓
 *                            ↓ 彻底失去引用
 *                            ↓
 *                         不可达状态 ->   垃圾回收
 *
 * 例如下面程序简单地创建了两个字符串对象，并创建了一个引用变量依次指向两个对象。
 * @author JIE
 */
public class StatusTransfer {

    public static void test() {
        // 1
        String a = new String("a1");
        // 2
        a = new String("a2");
    }

    public static void main(String[] args) {
        // 3
        test();
    }

    /**
     * 当程序执行test 方法的 1 代码时，代码定义了一个a 变量， 并让该变量指向"a1"字符串，
     * 该代码执行结束后，"a1"字符串对象处于可达状态。
     *
     * 当程序执行了test 方法的 2 代码后，代码再次创建了"a2"字符串对象， 并让a 变量指向该对象。
     * 此时，"a1"字符串对象处于可恢复状态,而"a2"字符串对象处于可达状态。
     *
     * 一个对象可以被一个方法的局部变量引用，也可以被其他类的类变量引用，或被其他对象的实例变量引用。
     * 当某个对象被其他类的类变量引用时，只有该类被销毁后，该对象才会进入可恢复状态: 当某个对象被其他对象的实例变量引用时，
     * 只有当该对象被销毁后，该对象才会进入可恢复状态。
     */
}

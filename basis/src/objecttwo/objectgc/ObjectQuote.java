package objecttwo.objectgc;

import java.lang.ref.WeakReference;

/**
 * 对象的软、弱和虚引用
 *
 * 对大部分对象而言，程序里会有一个引用变量引用该对象，这是最常见的引用方式。除此之外，
 * java.lang.ref 包下提供了3 个类: SoftReference 、PhantomReference 和WeakReference ，它们分别代表了
 * 系统对对象的3 种引用方式:软引用、虚引用和弱引用。因此， Java 语言对对象的引用有如下4 种方式
 * 1. 强引用(StrongReference)
 * 这是Java 程序中最常见的引用方式。程序创建一个对象，并把这个对象赋给一个引用变量，程序通过该引用变量来操作实际的对象，
 * 前面介绍的对象和数组都采用了这种强引用的方式。当一个对象被一个或一个以上的引用变量所引用时，它处于可达状态，不可能被系统垃圾回收机制回收。
 * 2.软引用(SoftReference)
 * 软引用需要通过SoftReference 类来实现，当一个对象只有软引用时，它有可能被垃圾回收机制回收。
 * 对于只有软引用的对象而言，当系统内存空间足够时，它不会被系统回收，程序也可使用该对象;
 * 当系统内存空间不足时，系统可能会回收它。软引用通常用于对内存敏感的程序中。
 * 3.弱引用(WeakReference)
 * 弱引用通过WeakReference 类实现，弱引用和软引用很像，但弱引用的引用级别更低。对于只有弱引用的对象而言，当系统垃圾回收机制运行时，不管系统内存是否足够，
 * 总会回收该对象所占用的内存。当然，并不是说当一个对象只有弱引用时，它就会立即被回收, 正如那些失去引用的对象一样，必须等到系统垃圾回收机制运行时才会被回收。
 * 4.虚引用(PhantomReference)
 * 虚引用通过PhantomReference 类实现，虚引用完全类似于没有引用。虚引用对对象本身没有太大影响，对象甚至感觉不到虚引用的存在。
 * 如果一个对象只有一个虚引用时，那么它和没有引用的效果大致相同。虚引用主要用于跟踪对象被垃圾回收的状态，
 * 虚引用不能单独使用，虚引用必须和引用队列( ReferenceQueue ) 联合使用。
 *
 * 上面三个引用类都包含了一个get()方法，用于获取被它们所引用的对象。
 *
 * 引用队列由java.lang.ref.ReferenceQueue 类表示，它用于保存被回收后对象的引用。当联合使用软引用、弱引用和引用队列时，
 * 系统在回收被引用的对象之后，将把被回收对象对应的引用添加到关联的引用队列中。与软引用和弱引用不同的是，虚引用在对象被释放之前，
 * 将把它对应的虚引用添加到它关联的引用队列中，这使得可以在对象被回收之前采取行动。
 *
 * 软引用和弱引用可以单独使用，但虚引用不能单独使用，单独使用虚引用没有太大的意义。虚引用的主要作用就是跟踪对象被垃圾回收的状态，
 * 程序可以通过检查与虚引用关联的引用队列中是否已经包含了该虚引用，从而了解虚引用所引用的对象是否即将被回收。
 *
 * 下面程序示范了弱引用所引用的对象被系统垃圾回收过程。
 * @author JIE
 */
public class ObjectQuote {

    public static void main(String[] args) {
        // 创建一个字符串对象
        String str = new String("str");
        // 创建一个弱引用，让此弱引用引用到"str" 字符串 1
        WeakReference wr = new WeakReference(str);
        // 切断str 引用和"str" 字符串之间的引用 2
        str = null;
        // 取出弱引用所引用的对象 3
        System.out.println(wr.get());
        // 强制垃圾回收
        System.gc();
        System.runFinalization();
        // 再次取出弱引用所引用的对象 4
        System.out.println(wr.get());
    }

    /**
     * 上面程序先创建了一个"str"宇符串对象，并让str位引用变量引用它，执行 1 代码时，系统创建了一个弱引用对象，并让该对象和str引用同一个对象。
     * 当程序执行到 2 代码时，程序切断了str和"str"字符串对象之间的引用关系。
     * 此时系统内存如图 所示。
     * 栈：str                    wr
     *     ↓                      ↓
     * 堆："str"     ←弱引用←    WeakReference对象
     *
     * 当程序执行到 3代码时，由于本程序不会导致内存紧张，此时程序通常还不会回收弱引用wr 所引用的对象，
     * 因此在 3 代码处可以看到输出"str"字符串。
     * 执行到 3 代码之后，程序调用了System.gc;和System.runFinalization;通知系统进行垃圾回收，如果系统立即进行垃圾回收，
     * 那么就会将弱引用wr 所引用的对象回收。接下来在 4 代码处将看到输出null 。
     */
}

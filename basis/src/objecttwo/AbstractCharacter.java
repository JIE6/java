package objecttwo;

/**
 * abstract修饰符
 *
 * 抽象方法和抽象类必须使用abstract 修饰符来定义， 有抽象方法的类只能被定义成抽象类，抽象类里可以没有抽象方法。
 * 抽象方法和抽象类的规则如下：
 * 1.抽象类必须使用abstract 修饰符来修饰，抽象方法也必须使用abstract 修饰符来修饰，抽象方法不能有方法体。
 * 2.抽象类不能被实例化， 无法使用new 关键字来调用抽象类的构造器创建抽象类的实例。即使抽象类里不包含抽象方法，这个抽象类也不能创建实例
 * 3.抽象类可以包含成员变量、方法(普通方法和抽象方法都可以)、构造器、初始化块、内部类(接口、枚举) 5 种成分。抽象类的构造器不能用于创建实例， 主要是用于被其子类调用。
 * 4.含有抽象方法的类( 包括直接定义了一个抽象方法: 或继承了一个抽象父类，但没有完全实现父类包含的抽象方法; 或实现了一个接口， 但没有完全实现接口包含的抽象方法三种情况)只能被定义成抽象类
 *
 * 归纳起来，抽象类可用"有得有失" 4 个字来描述。"得" 指的是抽象类多了一个能力: 抽象类可以包含抽象方法; " 失"指的是抽象类失去了一个能力: 抽象类不能用于创建实例。
 *
 * 定义抽象方法只需在普通方法上增加abstract 修饰符， 并把普通方法的方法体( 也就是方法后花括号括起来的部分〉全部去掉， 并在方法后增加分号即可。
 *
 * 定义抽象类只需在普通类上增加abstract 修饰符即可。甚至一个普通类(没有包含抽象方法的类)增加abstract 修饰符后也将变成抽象类。
 * @author JIE
 */

public abstract class AbstractCharacter {

    {
        System.out.println("执行AbstractCharacter初始化块...");
    }

    private String color;


    /**
     * 定义一个抽象的吃方法
     * @return
     * eat
     */
    public abstract String eat();

    /**
     * 定义构造器， 该构造器并不是用于创建对象
     * 而是用于被子类调用
     */
    public AbstractCharacter(String color) {
        System.out.println("执行AbstractCharacter构造器");
        this.color = color;
    }
}

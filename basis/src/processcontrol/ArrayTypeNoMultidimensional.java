package processcontrol;

/**
 * 重点
 * 数组类型-没有多维数组
 * Java 语言里提供了支持多维数组的语法。但没有多维数组，如果从数组底层的运行机制上来看。
 *
 * Java 语言里的数组类型是引用类型，因此数组变量其实是一个引用，这个引用指向真实的数组内存。
 * 数组元素的类型也可以是引用，如果数组元素的引用再次指向真实的数组内存，这种情形看上去很像多维数组。
 *
 * type[] [] arrName;
 * Java 语言采用上面的语法格式来定义二维数组，但它的实质还是一维数组，只是其数组元素也是引用， 数组元素里保存的引用指向一维数组。
 *
 * 接着对这个"二维数组"执行初始化， 同样可以把这个数组当成一维数组来初始化，把这个" 二维数组"当成一个一维数组，
 * 其元素的类型是type[]类型，则可以采用如下语法进行初始化:
 * arrName = new type[length] []
 *
 * 上面的初始化语法相当于初始化了一个一维数组， 这个一维数组的长度是length 。同样，因为这个一维数组的数组元素是引用类型(数组类型) 的，
 * 所以系统为每个数组元素都分配初始值: null 。
 *
 * 这个二维数组实际上完全可以当成一维数组使用： 使用new type[length]初始化一维数组后，相当于定义了length 个type 类型的变量:
 * 类似的，使用new type[length][] 初始化这个数组后，相当于定义了length 个type[] 类型的变量，当然，这些type[]类型的变量都是数组类型，
 * 因此必须再次初始化这些数组。
 *
 * @author JIE
 */
public class ArrayTypeNoMultidimensional {

    public static void main(String[] args) {
        // 定义一个二维数组
        int[][] iArrayA;
        // 把iArrayA 当成一维数组进行初始化， 初始化iArrayA 是一个长度为4 的数组
        // iArrayA 数组的数组元素又是引用类型
        iArrayA = new int[4][];
        // 把iArrayA 数组当成一维数组，遍历iArrayA 数组的每个数组元素
        for (int i = 0; i < iArrayA.length; i++) {
            System.out.println(iArrayA[i]);
        }
        // 初始化iArrayA 数组的第一个元素
        iArrayA[0] = new int[2];
        // 访问iArrayA 数组的第一个元素所指数组的第二个元素
        iArrayA[0][1] = 6;
        // iArrayA 数组的第一个元素是一个一维数组，遍历这个一维数组
        for (int i = 0; i < iArrayA[0].length; i++) {
            System.out.println(iArrayA[0][i]);
        }
        /**
         * 解析上面的程序
         * 上面程序中先iArrayA 这个二维数组当成一维数组处理，只是每个数组元素都是null ，所以看到输出结果都是null 。
         * 下面说明这个程序的执行过程。
         *
         * 程序的第一行int[][] iArrayA;
         * 将在栈内存中定义一个引用变量，这个变量并未指向任何有效的内存空间，此时的堆内存中还未为这行代码分配任何存储区。
         *
         * 程序对iArrayA 数组执行初始化: iArrayA = new int[4][]; ，这行代码让iArrayA 变量指向一块长度为4 的数组内存，这
         * 个长度为4 的数组里每个数组元素都是引用类型(数组类型) ，系统为这些数组元素分配默认的初始值:null 。此时iArrayA 数组在内存中的存储结构示例如下：
         * iArrayA（栈内存） ---> [null,         null,       null,       null](堆内存)
         *                      (iArrayA[0]),(iArrayA[1]),(iArrayA[2]),(iArrayA[3])
         * 虽然声明iArrayA 是一个二维数组，但这里丝毫看不出它是一个二维数组的样子，完全是一维数组的样子。
         * 这个一维数组的长度是4 ，只是这4 个数组元素都是引用类型，它们的默认值是null。所以程序中可以把iArrayA 数组当成一维数组处理，
         * 依次遍历iArrayA 数组的每个元素，将看到每个数组元素的值都是null 。
         *
         * 由于iArrayA 数组的元素必须是int[] 数组，所以接下来的程序对iArrayA[0]元素执行初始化，也就是让上面内存中的存储结构示例里 右边堆内存中的第一个
         * 数组元素指向一个有效的数组内存，指向一个长度为2 的int 数组。因为程序采用动态初始化iArrayA[0]数组，
         * 因此系统将为iArrayA[0]所引用数组的每个元素分配默认的初始值: 0 ， 然后程序显式为iArrayA[0]数组的第二个元素赋值为6 。此时在内存中的存储示例如下：
         *                         [0, 6](堆内存)
         * iArrayA（栈内存） ---> [↑↑↑↑↑↑↑↑,         null,       null,       null](堆内存)
         *                      (iArrayA[0]),(iArrayA[1]),(iArrayA[2]),(iArrayA[3])         */

        /**
         * 从上面程序中可以看出，初始化多维数组时， 可以只指定最左边维的大小; 当然，也可以一次指定每一维的大小
         */
        int[][] iArrayA2 = new int[3][4];
        /**
         * 上面代码将定义一个iArrayA2 数组变量，这个数组变量指向一个长度为3 的数组，这个数组的每个数组元
         * 素又是一个数组类型，它们各指向对应的长度为4 的int[]数组，每个数组元素的值为0.
         *
         * 还可以使用静态初始化方式来初始化二维数组。使用静态初始化方式来初始化二维数组时，二维数
         * 组的每个数组元素都是一维数组，因此必须指定多个一维数组作为二维数组的初始化值
         */
        // 使用静态初始化语法来初始化一个二维数组
        int[][] iArrayA3 = new int[][] {new int[1], new int[]{3, 4}};
        // 使用简化的静态初始化语法来初始化二维数组
        int[][] iArrayA4 ={new int[1], new int[]{3, 4}};

    }
}

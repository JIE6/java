package processcontrol;

/**
 * 重点
 * 数组类型-深入掌握
 * 知识点：
 * 1.数组引用变量只是一个引用， 这个引用变量可以指向任何有效的内存， 只有当该引用指向有效内存后，
 * 才可通过该数组变量来访问数组元素。
 * 2.与所有引用变量相同的是，引用变量是访问真实对象的根本方式。也就是说，如果希望在程序中访问数组对象本身，
 * 则只能通过这个数组的引用变量来访问它。
 *
 * 扩展：
 * 实际的数组对象被存储在堆( heap ) 内存中，如果引用该数组对象的数组引用变量是一个局部变量，
 * 那么它被存储在栈( stack) 内存中。数组在内存中的存储示例：
 * 数组变量P(栈内存) ---> P变量指向的实际数组对象（堆内存）
 * 如果需要访问上示例中的 P数组，则程序中只能通过p[index] 的形式实现。也就是说，数组引用变量是访问堆内存中数组元素的根本方式。
 *
 * 为什么会有堆内存，栈内存之分？
 * 当一个方法执行时，每个方法都会建立自己的内存栈，在这个方法里定义的变量将会逐个放入这块栈内存里，
 * 随着方法运行的结束，这个方法的内存栈也将自然销毁。因此所有在方法里定义的局部变量都在栈内存中；
 * 在程序中创建一个对象时，这个对象将被保存到运行时数据区中以便反复利用(因为对象创建成本通常较大)这个运行时数据区就是堆内存。
 * 堆内存中的对象不会随方法的结束而销毁，即使方法运行结束后，这个对象还可能被另一个引用变量所引用（在方法参数传递时很常见）
 * 则这个对象依然不会被销毁。只有当一个对象没有任何引用变量引用他时，系统的垃圾回收器才会在合适的时候回收它
 *
 * 如果堆内存中数组不再有任何引用变量指向自己，则这个数组将成为垃圾，该数组所占的内存将会
 * 被系统的垃圾回收机制回收。因此，为了让垃圾回收机制回收一个数组所占的内存空间，可以将该数组
 * 变量赋为null ，也就切断了数组引用变量和实际数组之间的引用关系，实际的数组也就成了垃圾。
 * @author JIE
 */
public class ArrayTypeGrasp {

    public static void main(String[] args) {
        /**
         * 只要类型相互兼容，就可以比一个数组变量指向另一个实际的数组，这种操作会让人产生数组的长
         * 度可变的错觉。如下代码所示。
         */
        int[] ia1 = {123, 46, 14, 7};
        System.out.println(ia1.length);
        int[] ia2 = new int[] {1, 9, 14};
        ia1 = ia2;
        System.out.println(ia1.length);
        System.out.println(ia2.length);
        /**
         * 因为ia1 是int[]类型， ia2 也是int[]类型，所以可以将ia2 的值赋给ia1
         * 也就是让ia1 引用指向ia2 引用指向的数组
         *
         * 程序运行结束后看到数组ia1的长度由4变成了3，看起来数组的长度似乎是可变的，但这只是一个假象。需牢记的是：
         * 定义并初始化一个数组后在内存中分配了两个空间，一个是用于存放数组的引用变量 也就是 ia1,ia2这些变量，另一个是用于
         * 存放实际的数据-数组的本身，如下所示
         * 数组变量ia1(栈内存) ---> 实际的数组[123, 46, 14, 7]（堆内存）
         * 数组变量ia2(栈内存) ---> 实际的数组[1, 9, 14]（堆内存）
         * 当 ia1 = ia2;执行后ia1的指向发生了变化
         * 数组变量ia1(栈内存) ---> 实际的数组[1, 9, 14]（堆内存）
         * 数组变量ia2(栈内存) ---> 实际的数组[1, 9, 14]（堆内存）
         * 当执行了ia1 = ia2;之后，堆内存中的第二个数组具有了两个引用: ia1 变量和ia2 变量都引用了第二个数组。
         * 此时第一个数组失去了引用，变成垃圾，只有等待垃圾回收机制来回收它。但它的长度依然不会改变，直到它彻底消失。
         *
         */



        /**
         *基本类型数组的初始化
         * 对于基本类型数组而言，数组元素的值直接存储在对应的数组元素中，因此，初始化数组时，先为该数组分配内存空间，
         * 然后直接将数组元素的值存入对应数组元素中。
         */
        int[] iAr1;
        iAr1 = new int[5];
        // 采用循环方式为每个数组元素赋值
        for (int i = 0; i < iAr1.length; i++) {
            iAr1[i] = i+1;
        }
        /**
         * 解析上面的程序-基本类型数组的初始化
         *
         * 执行第一行代码：
         * int[] iAr1;
         * 仅定义了一个数组变量iAr1，此时内存中的存储结构示例：
         * iAr1（栈内存） ---> null(堆内存)（此时堆内存里无任何数据）
         * 执行了int[] iAr1;后仅在栈内存中定义了一个空引用，这个引用并未指向任何有效的内存。
         *
         * 执行第二行代码：
         * iAr1 = new int[5];
         * 当执行了iAr1 = new int[5];动态初始化后，系统将负责为数组分配内存空间，并分配默认初始化值：
         * 此时所有数组元素都被赋为值0。此时内存中的存储结构示例：
         * iAr1（栈内存） ---> [0, 0, 0, 0, 0](堆内存)（动态初始化时系统分配的默认初始值详情参考ArrayTypeIntroduction.53行）
         * 此时iAr1数组的每个数组元素值均为0，当循环为数组元素依次赋值后此时每个数组元素的值都变成程序显示指定的值。此时内存中的存储结构示例
         * iAr1（栈内存） ---> [1, 2, 3, 4，5](堆内存)
         */

        /**
         * 引用类型数组的初始化
         * 引用类型数组的数组元素是引用，因此情况变得更加复杂。每个数组元素里存储的还是引用，
         * 它指向另一块内存，这块内存里存储了有效数据。
         * 为了更好地说明引用类型数组的运行过程，定义一个Person 类
         */
        // 定义一个 students数组变量，类型是Person[]
        Person[] students;
        // 执行动态初始化
        students = new Person[2];
        // 创建一个Person实例，并将这个Person实例赋值给zhangSan变量
        Person zhangSan = new Person();
        // 为zhangSan所引用的Person对象的name，age赋值
        zhangSan.name = "张三";
        zhangSan.age = 18;
        // 创建一个Person实例，并将这个Person实例赋值给lisi变量
        Person lisi = new Person();
        // 为lisi所引用的Person对象的name，age赋值
        lisi.name = "李四";
        lisi.age = 19;
        // 将zhangSan 变量的值赋给第一个数组元素
        students[0] = zhangSan;
        // 将lisi 变量的值赋给第二个数组元素
        students[1] = lisi;
        // 下面两行代码的结果完全一样，因为zhangSan和students[0]指向的是同一个Person实例
        zhangSan.info();
        students[0].info();
        /**
         * 解析上面的程序-引用类型数组的初始化
         *
         * 执行第一行代码：
         * Person[] students;
         * 这行代码仅仅在栈内存中定义了一个引用变量，也就是一个指针，这个指针并未指向任何有效的内存区。
         * 此时内存中的存储结构示例
         * students（栈内存） ---> null(堆内存)（此时堆内存里无任何数据）
         *
         * 执行第二行代码：
         * students = new Person[2];
         * 当执行了students = new Person[2];动态初始化后，系统将负责为数组分配内存空间，并分配默认初始化值：null
         * 此时内存中的存储结构示例
         * students（栈内存） ---> [null, null](堆内存)(动态初始化由系统为数组元素分配默认的初始值: null ，即每个数组元素的值都是null )
         *
         * students 数组的两个数组元素都是引用， 而且这个引用并未指向任何有效的内存， 因此每个数组元素的值都是null 。
         * 这意味着依然不能直接使用students 数组元素，因为每个数组元素都是nulL 这相当于定义了两个连续的Person 变量，
         * 但这个变量还未指向任何有效的内存区，所以这两个连续的Person 变量(students 数组的数组元素)还不能使用。
         *
         * 接着的代码定义了zhangSan 和lisi 两个Person 实例， 定义这两个实例实际上分配了4 块内存，
         * 在栈内存中存储了zhangSan 和lisi 两个引用变量，还在堆内存中存储了两个Person 实例。此时内存中的存储大致结构示例
         * zhangSan（栈内存） ---> Person-zhangSan{"张三", 18}(堆内存)
         * lisi（栈内存） ---> Person-lisi{"李四", 19}(堆内存)
         * students（栈内存） ---> [Person-zhangSan, Person-lisi](堆内存)
         *
         * 此时zhangSan 和students[0]指向同一个内存区， 而且它们都是引用类型变量，
         * 因此通过zhangSan 和students[0]来访问Person实例的实例变量和方法的效果完全一样，
         * 不论修改students[0]所指向的Person 实例的实例变量，还是修改zhangSan 变量所指向的Person 实例的实例变量，
         * 所修改的其实是同一个内存区，所以必然互相影响。同理， lisi 和students[1]也是引用同一个Person 对象，也具有相同的效果。
         * 下列程序为证
         */
        zhangSan.name = "张三-1";
        zhangSan.info();
        students[0].info();

        students[1].name = "李四-2";
        lisi.info();
        students[1].info();
    }

}

class Person{
    /**
     * 姓名
     */
    public String name;
    /**
     * 年龄
     */
    public int age;

    public void info() {
        System.out.println("我的姓名是："+name+"，年龄："+age+"岁.");
    }
}

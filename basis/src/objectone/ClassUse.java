package objectone;

/**
 * 重点
 * （定义类-使用）与（对象、引用和指针）
 * 定义类之后，接下来即可使用该类了， Java 的类大致有如下作用。
 * 1.定义变量。
 * 2.创建对象。
 * 3.调用类的类方法或访问类的类变量。
 *
 * @author JIE
 */
public class ClassUse {

    public static void main(String[] args) {
        // 使用Peron 类定义一个Person 类型的变量
        Person p;
        // 通过new 关键字调用Person 类的构造器，返回一个Person 实例
        // 将该Person 实例赋给p 变量
        p = new Person();

        // 上面代码也可简写成如下形式:定义p 变量的同时并为p 变量赋值 Person p = new Person();

        /*
         * 创建对象之后，接下来即可使用该对象了， Java 的对象大致有如下作用。
         *
         * 访问对象的实例变量。
         * 调用对象的方法。
         *
         * 如果访问权限允许，类里定义的方法和成员变量都可以通过类或实例来调用。
         * 类或实例访问方法或成员变量的语法是:类.类变量|方法，或者实例.实例变量|方法，在这种方式中，
         * 类或实例是主调者，用于访问该类或该实例的成员变量或方法。
         *
         *static 修饰的方法和成员变量，既可通过类来调用，也可通过实例来调用;
         * 没有使用static 修饰的普通方法和成员变量，只可通过实例来调用。
         * 下面代码中通过Person 实例来调用Person 的成员变量和方法
         */

        // 访问p 的name 实例变量，直接为该变量赋值
        p.name = "张三";

        // 调用p 的say ()方法，声明say ()方法时定义了一个形参。调用该方法必须为形参指定一个值
        p.say("J-A-V-A");
        // 直接输出p 的name 实例变量，将输出张三
        System.out.println(p.name);

        /*
         * 上面代码中通过Person 实例调用了say()方法，调用方法时必须为方法的形参赋值。
         * 因此在这行代码中调用Person 对象的say()方法时，必须为say()方法传入一个字符串作为形参的参数值，
         * 这个字符串将被赋给content 参数。
         *
         * 大部分时候，定义一个类就是为了重复创建该类的实例，同一个类的多个实例具有相同的特征，
         * 而类则是定义了多个实例的共同特征。从某个角度来看，类定义的是多个实例的特征，因此类不是一种具体存在，
         * 实例才是具体存在。完全可以这样说:你不是人这个类，我也不是人这个类，我们都只是人的实例。
         */

        /**
         * 对象、引用和指针
         * Person p = new Person();
         *
         * 这行代码创建了一个Person 实例，也被称为Person 对象，这个Person 对象被赋给 p 变量。
         *
         * 在这行代码中实际产生了两个东西: 一个是p 变量，一个是Person 对象。
         *
         * 从Person 类定义来看， Person 对象应包含两个实例变量，而变量是需要内存来存储的。
         * 因此， 当创建Person 对象时，必然需要有对应的内存来存储Person 对象的实例变量
         * 存储示意图如下：
         *       "张三"
         * （name:↑↑↑↑↑, age:0）堆内存
         *
         * 从上面的示意图中可以看出， Person 对象由多块内存组成， 不同内存块分别存储了Person 对象的不同成员变量。
         * 当把这个Person 对象赋值给一个引用变量时， 系统如何处理呢?难道系统会把这个Person 对象在内存里重新复制一份吗?
         * 显然不会， Java 没有这么笨， Java 让引用变量指向这个对象即可。也就是说，引用变量里存放的仅仅是一个引用， 它指向实际的对象。
         *
         * 与前面介绍的数组类型类似，类也是一种引用数据类型，因此程序中定义的Person 类型的变量实际上是一个引用，
         * 它被存放在栈内存里， 指向实际的Person 对象: 而真正的Person 对象则存放在堆（ heap )内存中。
         *
         * 栈内存里的引用变量并未真正存储对象的成员变量， 对象的成员变量数据实际存放在堆内存里:
         * 而引用变量只是指向该堆内存里的对象。从这个角度来看， 引用变量与C 语言里的指针很像， 它们都是
         * 存储一个地址值， 通过这个地址来引用到实际对象。实际上， Java 里的引用就是C 里的指针，
         * 只是Java语言把这个指针封装起来，避免开发者进行烦琐的指针操作。
         *
         * 当一个对象被创建成功以后，这个对象将保存在堆内存中， Java 程序不允许直接访问堆内存中的对象，
         * 只能通过该对象的引用操作该对象。也就是说， 不管是数组还是对象，都只能通过引用来访问它们。
         *
         * p 引用变量本身只存储了一个地址值，并未包含任何实际数据， 但它指向实际的Person对象，
         * 当访问p 引用变量的成员变量和方法时， 实际上是访问p 所引用对象的成员变量和方法。
         *
         * 不管是数组还是对象， 当程序访问引用变量的成员变量或方法时，实际上走访问该引用变量所引用的数组、对象的成员变量或方法。
         *
         * 堆内存里的对象可以有多个引用， 即多个引用变量指向同一个对象， 代码如下
         * Person p2 = p;
         *
         * 上面代码把p 变量的值赋值给p2 变量， 也就是将p 变量保存的地址值赋给p2 变量， 这样p2 变量和
         * p 变量将指向堆内存里的同一个Person 对象。不管访问p2 变量的成员变量和方法，还是访问p 变量的成
         * 员变量和方法，它们实际上是访问同一个Person 对象的成员变量和方法，将会返回相同的访问结果。
         *
         * 如果堆内存里的对象没有任何变量指向该对象， 那么程序将无法再访问该对象， 这个对象也就变成
         * 了垃圾， Java 的垃圾回收机制将回收该对象，释放该对象所占的内存区。因此，如果希望通知垃圾回收机制回收某个对象，
         * 只需切断该对象的所有引用变量和它之间的关系即可，也就是把这些引用变量赋值为null。
         */
    }
}

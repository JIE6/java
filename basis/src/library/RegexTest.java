package library;

/**
 * 正则表达式-介绍
 *
 * 正则表达式就是一个用于匹配字符串的模板，可以匹配一批字符串，所以创建正则表达式就是创建一个特殊的字符串。正则表达式所支持的合法字符如下表 所示。
 * ---------------------------------------------------------------------------------------------------------------------------
 * 字符               解释
 * ---------------------------------------------------------------------------------------------------------------------------
 * x                字符x (x可代表任何合法的字符)
 * \0mnn            八进制数 0mnn 所表示的字符
 * \xhh             十六进制数 0xhh 所表示的字符
 * \\uhhhh           十六进制数 0xhhhh 所表示的 Unicode 字符
 * \t               制表符 \u0009
 * \n               新行 （换行）符 \u000A
 * \r               回车符 \u000D
 * \f               换页符 \u000C
 * \a               报警(bell)符 \u0007
 * \e               Escape符 \u001B
 * \cx              x 对应的的控制符。例如， \cM 匹配Ctrl-M ， x 值必须为A-Z 或a吃之一。
 * ---------------------------------------------------------------------------------------------------------------------------
 * 除此之外，正则表达式中有一些特殊字符，这些特殊字符在正则表达式中有其特殊的用途，比如前面介绍的反斜线(\) 。
 * 如果需要匹配这些特殊字符，就必须首先将这些宇符转义，也就是在前面添加一个反斜线(\) 。正则表达式中的特殊字符下表 所示。
 * ---------------------------------------------------------------------------------------------------------------------------
 * 特殊字符             说明
 * ---------------------------------------------------------------------------------------------------------------------------
 * $                 匹配一行的结尾。要匹配$ 字符本身， 请使用\$
 * ^                 匹配一行的开头。要匹配^ 字符本身， 请使用\^
 * ()                标记子表达式的开始和结束位置。要匹配这些字符，请使用\( 和 \)
 * []                用于确定中括号表达式的开始和结束位置。要匹配这些字符，请使用\[ 和 \]
 * {}                用于标记前面子表达式的出现频度。要匹配这些字符，请使用\{ 和 \}
 * *                 指定前面子表达式可以出现零次或多次。要匹配*字符本身，请使用\*
 * +                 指定前面子表达式可以出现一次或多次。要匹配+字符本身，请使用\+
 * ?                 指定前面子表达式可以出现零次或一次。要匹配?字符本身，请使用\?
 * .                 匹配除换行符\n之外的任何单字符。要匹配.字符本身，请使用\
 * \                 用于转义下一个字符，或指定八进制、十六进制字符。如果需匹配\字符， 请用\\
 * |                 指定两项之间任选一项。如果要匹配|字符本身, 请使用\|
 * ---------------------------------------------------------------------------------------------------------------------------
 * 将上面多个字符拼起来， 就可以创建一个正则表达式。例如:
 * "\u0041\\\\"  匹配 A\
 * "\u0061\t"    匹配 a<制表符>
 * "\\?\\["      匹配 ?[
 * 觉得第一个正则表达式中怎么有那么多反斜杠?
 * 这是由于Java 字符串中反斜杠本身需要转义， 因此两个反斜杠( \\ )实际上相当于一个(前一个用于转义)。
 *
 * 上面的正则表达式依然只能匹配单个字符，这是因为还未在正则表达式中使用"通配符"，"通配符"是可以匹配多个字符的特殊字符。
 * 正则表达式中的"通配符"远远超出了普通通配符的功能，它被称为预定义字符，正则表达式支持如下表所示的预定义字符。
 * ---------------------------------------------------------------------------------------------------------------------------
 * 预定义字符            说明
 * ---------------------------------------------------------------------------------------------------------------------------
 * .                    可以匹配任何字符
 * \d                   匹配0-9 的所有数字
 * \D                   匹配非数字
 * \s                   匹配所有的空白字符，包括空格、制表符、回车符、换页符、换行符等
 * \S                   匹配所有的非空白字符
 * \w                   匹配所有的单词字符，包括0-9 所有数字、26 个英文字母和下划线_
 * \W                   匹配所有的非单词字符
 * ---------------------------------------------------------------------------------------------------------------------------
 * 上面的7 个预定义字符其实很容易记忆d 是digit 的意思，代表数字， s 是space的意思， 代表空白， W 是word 的意思， 代表单词。
 * d 、s 、w 的大写形式恰好匹配与之相反的字符。
 *
 * 有了上面的预定义字符后，接下来就可以创建更强大的正则表达式了。例如:
 * c\\wt    可以匹配cat 、cbt 、cct 、cOt 、c9t 等一批字符串
 * \\d\\d\\d-\\d\\d\\d-\\d\\d\\d\\d     匹配如000-000-0000 形式的电话号码
 *
 * 在一些特殊情况下，例如，若只想、匹配a~ f 的字母，或者匹配除ab 之外的所有小写字母，或者匹配中文字符，上面这些预定义字符就无能为力了，
 * 此时就需要使用方括号表达式，方括号表达式有如下表所示的几种形式。
 * ---------------------------------------------------------------------------------------------------------------------------
 * 方括号表达式                说明
 * ---------------------------------------------------------------------------------------------------------------------------
 * 表不枚举                 例如[abc] ，表示a 、b 、c 其中任意一个字符[gz] ， 表示g 、z 其中任意一个字符
 * 表示范围:-               例如[a-f]，表示a-f 范围内的任意字符, 范围可以和枚举结合使用，如[a-cx-z] ，表示a~c、x-z 范围内的任意字符
 * 表不求否:^               例如[^abc] ，表示非a 、b 、c 的任意字符[^a-f]，表示不是a-f 范围内的任意字符
 * 表示"与"运算:&&          例如[a-z&&[def]] ， 求a-z和[def] 的交集， 表示d 、e 或f， [a-z&&[^m-p]], a-a范围内的所有字符，除m-p 范围之外的字符， 即[a-lq-z]
 * 表示"并"运算             并运算与前面的枚举类似。例如[a-d[m-p]] ，表示[a-dm-p]
 * ---------------------------------------------------------------------------------------------------------------------------
 *
 * 正则表示还支持圆括号表达式，用于将多个表达式组成一个子表达式，圆括号中可以使用或运算符|例如， 正则表达式"((public)|(Protected)|(private))"用于匹配Java 的三个访问控制符其中之一。
 * 除此之外， Java 正则表达式还支持如下表 所示的几个边界匹配符。
 * ---------------------------------------------------------------------------------------------------------------------------
 * 边界匹配符                    说明
 * ---------------------------------------------------------------------------------------------------------------------------
 * ^                            行的开头
 * $                            行的结尾
 * \b                           单词的边界
 * \B                           非单词的边界
 * \A                           输入的开头
 * \G                           前一个匹配的结尾
 * \G                           前一个匹配的结尾
 * \Z                           输入的结尾，仅用于最后的结束符
 * \z                           输入的结尾
 * ---------------------------------------------------------------------------------------------------------------------------
 * 前面例子中需要建立一个匹配000-000-0000 形式的电话号码时， 使用了\\d\\d\\d-\\d\\d\\d-\\d\\d\\d\\d正则表达式，这看起来比较烦琐。
 * 实际上，正则表达式还提供了数量标识符，正则表达式支持的数量标识符有如下几种模式。
 * 1.Greedy (贪婪模式):数量表示符默认采用贪婪模式，除非另有表示。贪婪模式的表达式会一直匹配下去， 直到无法匹配为止。如果你发现表达式匹配的结果与预期的不符，
 * 很有可能是因为你以为表达式只会匹配前面几个宇符，而实际上它是贪婪模式，所以会一直匹配下去。
 * 2.Reluctant (勉强模式):用问号后缀(?)表示，它只会匹配最少的字符。也称为最小匹配模式。
 * 3.Possessive (占有模式) : 用加号后缀(+)表示，目前只有Java 支持占有模式， 通常比较少用
 *
 * 三种模式的数量表示符如下表 所示。
 * ---------------------------------------------------------------------------------------------------------------------------
 * 贪婪模式                     勉强模式                        占有模式                        说明
 * ---------------------------------------------------------------------------------------------------------------------------
 * X?                           X??                          X?+                        X 表达式出现零次或一次
 * X*                           X*?                          X*+                        X 表达式出现零次或多次
 * X+                           X+?                          X++                        X 表达式出现一次或多次
 * X{n}                         X{n}?                        X{n}+                      X 表达式出现n 次
 * X{n,}                        X{n,}?                       X{n,}+                     X 表达式最少出现n 次
 * X{n,m}                       X{n,m}?                      X{n,m}+                    X 表达式最少出现n 次，最多出现m 次
 * ---------------------------------------------------------------------------------------------------------------------------
 * 关于贪婪模式和勉强模式的对比， 看如下代码:
 * String str = "hello , java!";
 * // 贪婪模式的正则表达式
 * // 输出：- , java!
 * System.out.println(str.replaceFirst("\\w*", "-"));
 * // 勉强模式的正则表达式
 * // 输出：-hello , java!
 * System.out.println(str.replaceFirst("\\w*?", "-"));
 * 当从"hello ， java!"字符串中查找匹配"\\w*"子串时，因为"\w*"使用了贪婪模式， 数量表示符( * )会一直匹配下去， 所以该字符串前面的所有单词字符都被它匹配到，
 * 直到遇到空格，所以替换后的效果是- , java!, 如果使用勉强模式， 数量表示符(*)会尽量匹配最少字符，即匹配0 个字符， 所以替换后的结果是-hello , java!
 */

import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * 正则表达式-使用
 *
 * 一旦在程序中定义了正则表达式，就可以使用Pattern 和Matcher 来使用正则表达式。
 *
 * Pattern 对象是正则表达式编译后在内存中的表示形式，因此， 正则表达式宇符串必须先被编译为Pattern 对象， 然后再利用该Pattern 对象创建对应的Matcher 对象。
 * 执行匹配所涉及的状态保留在Matcher对象中， 多个Matcher 对象可共享同一个Pattern 对象
 * 因此， 典型的调用顺序如下
 * // 将一个字符串编译成Pattern 对象
 * Pattern p = Pattern.compile("a*b");
 * // 使用Pattern 对象创建Matcher 对象
 * Matcher m = p.matcher("aaaaab");
 * // 返回true
 * boolean b = m.matches();
 * @author JIE
 *
 * 上面定义的Pattern 对象可以多次重复使用。如果某个正则表达式仅需一次使用， 则可直接使用Pattern 类的静态matches()方法，
 * 此方法自动把指定字符串编译成匿名的Pattem 对象，并执行匹配， 如下所示。
 * // 返回true
 * boolean b = Pattern.matches("a*b", "aaaaab");
 * 上面语句等效于前面的三条语句。但采用这种语句每次都需要重新编译新的Pattem 对象，不能重复利用己编译的Pattem 对象， 所以效率不高
 * Pattern 是不可变类， 可供多个并发线程安全使用。
 * Matcher 类提供了如下几个常用方法。
 * find(): 返回目标字符串中是否包含与Pattern 匹配的子串。
 * group(): 返回上一次与Pattern 匹配的子串。
 * start(): 返回上一次与Pattern 匹配的子串在目标字符串中的开始位置。
 * end(): 返回上一次与Pattern 匹配的子串在目标字符串中的结束位置加1 。
 * lookingAt() : 返回目标字符串前面部分与Pattern 是否匹配。
 * matches(): 返回整个目标字符串与Pattern 是否匹配。
 * reset(): 将现有的Matcher 对象应用于一个新的字符序列。
 *
 * 在Pattem 、Matcher 类的介绍中经常会看到一个CharSequence 接口，该接口代表一个字符序列，其中CharBuffer、String 、StringBuffi町、StringBuilder 都是它的实现类。
 * 简单地说， CharSequence 代表一个各种表示形式的字符串。
 *
 * 通过Matcher 类的find()和group()方法可以从目标字符串中依次取出特定子串(匹配正则表达式的子串) ，例如互联网的网络爬虫， 它们可以自动从网页中识别出所有的电话号码。
 * 下面程序示范了如何从大段的宇符串中找出电话号码。
 * */
public class RegexTest {
    public static final String FIND_PHONE = "((13)|(15))\\d{9}";
    public static final String REQ_STR = "\\w+";
    public static final String EMAIL = "(\\w{3,20})(@)(\\w+)(\\.)(com|org|cn|net|gov)";
    public static final String RE_MATCHER = "re\\w*";

    public static void main(String[] args) {
        // 使用字符串模拟从网络上得到的网页源码
        String str = "我想求购一本《疯狂Java 讲义)) ，尽快联系我13500006666"
                + "交朋友，电话号码是13611125565"
                + "出售二手电脑，联系方式15899903312";
        // 创建一个Pattern 对象，并用它建立一个Matcher 对象, 该正则表达式只抓取13X 和15X 段的手机号, 实际要抓取哪些电话号码，只要修改正则表达式即可
        Matcher matcher = Pattern.compile(FIND_PHONE).matcher(str);
        // 将所有符合正则表达式的子串(电话号码)全部输出
        while (matcher.find()) {
            System.out.println(matcher.group());
        }
        // 从上面运行结果可以看出， find()方法依次查找字符串中与Pattern 匹配的子串， 一旦找到对应的子串，下次调用find()方法时将接着向下查找。
        // 通过程序运行结果可以看出，使用正则表达式可以提取网页上的电话号码， 也可以提邮件地址等信息。如果程序再进一步，
        // 可以从网页上提取超链接信息，再根据超脱打开其他网页，然后在其他网页上重复这个过程 实现简单的网络爬虫了
        /**
         * find()方法还可以传入一个int 类型的参数，带int 参数的find()方法将从该int 索引处向下搜索。
         * start()和end()方法主要用于确定子串在目标字符串中的位置，如下程序所示。
         */
        // 创建一个Pattern 对象，并用它建立一个Matcher 对象
        String reqStr = "Java is very easy!";
        System.out.println("目标字符串是：" + reqStr);
        Matcher matcher1 = Pattern.compile(REQ_STR).matcher(reqStr);
        while (matcher1.find()) {
            System.out.println(matcher1.group() + "， 子串的起始位置: " + matcher1.start() + "其结束位置: " + matcher1.end());
        }
        /**
         * matches()和lookingAt()方法有点相似，只是matches()方法要求整个字符串和Pattern 完全匹配时才返回true ，
         * 而lookingAt()只要字符串以Pattern 开头就会返回true, reset()方法可将现有的Matcher 对象应用于新的字符序列。看如下例子程序。
         */
        String[] mails = {"kongyeeku@163.com", "kongyeeku@qq.com", "wa@abc.com", "qq@gmail.com", "18546qq"};
        Pattern mailPattern = Pattern.compile(EMAIL);
        Matcher matcher2 = null;
        for (String mail : mails) {
            if (matcher2 == null) {
                matcher2 = mailPattern.matcher(mail);
            }else {
                matcher2.reset(mail);
            }
            String result = mail + (matcher2.matches() ? "是" : "不是") + "一个有效的邮箱地址";
            System.out.println(result);
        }

        /**
         * 上面程序创建了一个邮件地址的Pattern ，接着用这个Pattern 与多个邮件地址进行匹配。当程序中的Matcher 为null 时，
         * 程序调用matcher()方法来创建一个Matcher 对象， 一旦Matcher 对象被创建，程序就调用Matcher 的reset()方法将该Matcher 应用于新的字符序列。
         *
         * 从某个角度来看， Matcher 的matches() 、lookingAt()和String 类的equals() 、startsWith()有点相似。
         * 区别是String 类的equals()和startsWith()都是与字符串进行比较，而Matcher 的matches()和lookingAt()则是与正则表达式进行匹配。
         *
         * 除此之外，还可以利用正则表达式对目标字符串进行分割、查找、替换等操作，看如下例子程序。
         */
        String[] msgs = {"Java has regular expressions in 1.4", "regular expressions now expressing in Java", "Java represses oracular expressions"};
        Pattern p = Pattern.compile(RE_MATCHER);
        Matcher matcher3 = null;
        for (String msg : msgs) {
            if (matcher3 == null) {
                matcher3 = p.matcher(msg);
            }else {
                matcher3 = matcher3.reset(msg);
            }
            System.out.println(matcher3.replaceAll("哈哈：）"));
        }
        /**
         * 上面程序使用了Matcher 类提供的replaceAll()把字符串中所有与正则表达式匹配的子串替换成" 哈哈:) " ，
         * 实际上， Matcher 类还提供了一个replaceFirst()， 该方法只替换第一个匹配的子串。
         * 运行上面程序，会看到字符串中所有以" re " 开头的单词都会被替换成"哈哈:) "。
         *
         * 实际上， String 类中也提供了replaceAll() 、replaceFirst() 、split()等方法
         */
    }
}
